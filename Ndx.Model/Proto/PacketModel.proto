//  
// Copyright (c) BRNO UNIVERSITY OF TECHNOLOGY. All rights reserved.  
// Licensed under the MIT License. See LICENSE file in the solution root for full license information.  
//
syntax = "proto3";
package ndx.model;
option java_package = "org.ndx.model";
import "Constants.proto";

/// <summary>
/// Represents a single captured packet and its metadata
/// </summary>
message Frame {
    DataLinkType LinkType = 1;
	/// <summary>
    /// Gets or sets frame number.
    /// </summary>	
	int32 FrameNumber = 2;
    /// <summary>
    /// Gets or sets the total lenght of the frame.
    /// </summary>	
	int32 FrameLength = 3;
    /// <summary>
    /// Gets or sets the offset of the frame in the source file/stream.
    /// </summary>	
	int64 FrameOffset = 4;
    /// <summary>
    /// Gets or sets the timestamp when the packet was captured.
    /// </summary>		
	int64 TimeStamp = 5;	
	/// <summary>
	///	Gets or sets process id.
	/// </summary>
	int64 ProcessId = 6;
	/// <summary>
	///	Gets or sets process name.
	///	</summary>
	string ProcessName = 7;
	/// <summary>
    /// Gets or sets the raw frame content.
    /// </summary>	
	bytes Data = 10;
	/// <summary>
	///	Gets or sets the conversation ID of this frame.
	///	</summary>
	int32 ConversationId = 11;
}

message Variant {
	oneof Value {
		bool BoolValue = 1;
	    sint32 Int32Value = 2;
		sint64 Int64Value = 3;
	    uint32 UInt32Value = 4;
		uint64 UInt64Value = 5;
		float FloatValue = 6;
		double DoubleValue = 7;
		string StringValue = 8;
		bytes BytesValue = 9;
		string IpAddressValue = 10;
		int64 DateTimeValue = 11;
	}
}

message DecodedFrame {

	int64 FrameNumber = 1;
	string FrameProtocols = 2;
	int64 Timestamp = 3;
	map<string, Variant> Fields = 10;
}


message Parameter {
	string Name = 1;
	map<string,Variant> Properties = 2;
}

message Event {
	message EventValue {
		oneof ValueType {
			Variant VariantValue = 1;
			DecodedFrame PacketValue = 2;
			Parameter ParameterValue = 4;
		}
	}

	string Name = 1;
	int64 Timestamp = 2;
	map<string,EventValue> Items = 3; 
}

enum FieldType {
	FT_NONE = 0;			/* used for text labels with no value */
	FT_PROTOCOL = 1;
	FT_BOOLEAN = 2;			/* TRUE and FALSE come from <glib.h> */
	FT_CHAR = 3;			/* 1-octet character as 0-255 */
	FT_UINT8 = 4;
	FT_UINT16 = 5;
	FT_UINT24 = 6;			/* really a UINT32, but displayed as 6 hex-digits if FD_HEX*/
	FT_UINT32 = 7;
	FT_UINT40 = 8;			/* really a UINT64, but displayed as 10 hex-digits if FD_HEX*/
	FT_UINT48 = 9;			/* really a UINT64, but displayed as 12 hex-digits if FD_HEX*/
	FT_UINT56 = 10;			/* really a UINT64, but displayed as 14 hex-digits if FD_HEX*/
	FT_UINT64 = 11;
	FT_INT8 = 12;
	FT_INT16 = 13;
	FT_INT24 = 14;			/* same as for UINT24 */
	FT_INT32 = 15;
	FT_INT40 = 16;			/* same as for UINT40 */
	FT_INT48 = 17;			/* same as for UINT48 */
	FT_INT56 = 18;			/* same as for UINT56 */
	FT_INT64 = 19;
	FT_IEEE_11073_SFLOAT = 20;
	FT_IEEE_11073_FLOAT = 21;
	FT_FLOAT = 22;
	FT_DOUBLE = 23;
	FT_ABSOLUTE_TIME = 24;
	FT_RELATIVE_TIME = 25;
	FT_STRING = 26;
	FT_STRINGZ = 27;		/* for use with proto_tree_add_item() */
	FT_UINT_STRING = 28;	/* for use with proto_tree_add_item() */
	FT_ETHER = 29;
	FT_BYTES = 30;
	FT_UINT_BYTES = 31;
	FT_IPv4 = 32;
	FT_IPv6 = 33;
	FT_IPXNET = 34;
	FT_FRAMENUM = 35;		/* a UINT32, but if selected lets you go to frame with that number */
	FT_PCRE = 36;			/* a compiled Perl-Compatible Regular Expression object */
	FT_GUID = 37;			/* GUID, UUID */
	FT_OID = 38;			/* OBJECT IDENTIFIER */
	FT_EUI64 = 39;
	FT_AX25 = 40;
	FT_VINES = 41;
	FT_REL_OID	 = 42;		/* RELATIVE-OID */
	FT_SYSTEM_ID = 43;
	FT_STRINGZPAD = 44;		/* for use with proto_tree_add_item() */
	FT_FCWWN = 45;
	FT_NUM_TYPES = 46;		/* last item number plus one */
}

enum FieldDisplay {
	BASE_NONE    = 0;   /**< none */
	BASE_DEC     = 1;   /**< decimal */
	BASE_HEX     = 2;   /**< hexadecimal */
	BASE_OCT     = 3;   /**< octal */
	BASE_DEC_HEX = 4;   /**< decimal (hexadecimal) */
	BASE_HEX_DEC = 5;   /**< hexadecimal (decimal) */
	BASE_CUSTOM  = 6;   /**< call custom routine (in ->strings) to format */
	STR_UNICODE  = 7;   /**< shows non-printable UNICODE characters as \\uXXXX (XXX for now non-printable characters display depends on UI) */
	SEP_DOT      = 8;   /**< hexadecimal bytes with a period (.) between each byte */
	SEP_DASH     = 9;   /**< hexadecimal bytes with a dash (-) between each byte */
	SEP_COLON    = 10;  /**< hexadecimal bytes with a colon (:) between each byte */
	SEP_SPACE    = 11;  /**< hexadecimal bytes with a space between each byte */
	/* Address types */
	BASE_NETMASK = 12;  /**< Used for IPv4 address that shouldn't be resolved (like for netmasks) */

/* Port types */
	BASE_PT_UDP  = 13;  /**< UDP port */
	BASE_PT_TCP  = 14;  /**< TCP port */
	BASE_PT_DCCP = 15;  /**< DCCP port */
	BASE_PT_SCTP = 16;  /**< SCTP port */

/* OUI types */
	BASE_OUI     = 17;   /**< OUI resolution */
}

/// <summary> 
///	Information describing a header field.
///	</summary>
message FieldDefinition {
	/// <summary>
	/// Full name of this field.
	/// </summary>
	string Name = 1;
	/// <summary>
	///	Field type, one of FT_  value.
	///	</summary>
	FieldType Type = 2;
	///	<summary>
	///	One of BASE_, or field bit-width if FT_BOOLEAN 
	///	</summary>
	FieldDisplay Display = 3;
	///	<summary>
	/// Brief description of field.
	///	</summary>
	string Info = 4;
} 

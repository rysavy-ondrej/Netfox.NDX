// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Constants.proto

package org.ndx.model;

public final class Constants {
  private Constants() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * <pre>
   *&#47; &lt;summary&gt;
   * /	This is a list of link-layer header types used in pcap and pcap-ng capture files. See
   * / See http://www.tcpdump.org/linktypes.html
   * / &lt;/summary&gt;
   * </pre>
   *
   * Protobuf enum {@code ndx.model.DataLinkType}
   */
  public enum DataLinkType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>Null = 0;</code>
     */
    Null(0),
    /**
     * <code>Ethernet = 1;</code>
     */
    Ethernet(1),
    /**
     * <code>ExperimentalEthernet3MB = 2;</code>
     */
    ExperimentalEthernet3MB(2),
    /**
     * <code>AmateurRadioAX25 = 3;</code>
     */
    AmateurRadioAX25(3),
    /**
     * <code>ProteonProNetTokenRing = 4;</code>
     */
    ProteonProNetTokenRing(4),
    /**
     * <code>Chaos = 5;</code>
     */
    Chaos(5),
    /**
     * <code>Ieee802 = 6;</code>
     */
    Ieee802(6),
    /**
     * <code>ArcNet = 7;</code>
     */
    ArcNet(7),
    /**
     * <code>Slip = 8;</code>
     */
    Slip(8),
    /**
     * <code>Ppp = 9;</code>
     */
    Ppp(9),
    /**
     * <code>Fddi = 10;</code>
     */
    Fddi(10),
    /**
     * <code>AtmRfc1483 = 11;</code>
     */
    AtmRfc1483(11),
    /**
     * <code>Raw = 12;</code>
     */
    Raw(12),
    /**
     * <code>SlipBSD = 15;</code>
     */
    SlipBSD(15),
    /**
     * <code>PppBSD = 16;</code>
     */
    PppBSD(16),
    /**
     * <code>AtmClip = 19;</code>
     */
    AtmClip(19),
    /**
     * <code>PppSerial = 50;</code>
     */
    PppSerial(50),
    /**
     * <code>CiscoHDLC = 104;</code>
     */
    CiscoHDLC(104),
    /**
     * <code>Ieee80211 = 105;</code>
     */
    Ieee80211(105),
    /**
     * <code>Loop = 108;</code>
     */
    Loop(108),
    /**
     * <code>LinuxSLL = 113;</code>
     */
    LinuxSLL(113),
    /**
     * <code>Ieee80211_Radio = 127;</code>
     */
    Ieee80211_Radio(127),
    /**
     * <code>PerPacketInformation = 192;</code>
     */
    PerPacketInformation(192),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>Null = 0;</code>
     */
    public static final int Null_VALUE = 0;
    /**
     * <code>Ethernet = 1;</code>
     */
    public static final int Ethernet_VALUE = 1;
    /**
     * <code>ExperimentalEthernet3MB = 2;</code>
     */
    public static final int ExperimentalEthernet3MB_VALUE = 2;
    /**
     * <code>AmateurRadioAX25 = 3;</code>
     */
    public static final int AmateurRadioAX25_VALUE = 3;
    /**
     * <code>ProteonProNetTokenRing = 4;</code>
     */
    public static final int ProteonProNetTokenRing_VALUE = 4;
    /**
     * <code>Chaos = 5;</code>
     */
    public static final int Chaos_VALUE = 5;
    /**
     * <code>Ieee802 = 6;</code>
     */
    public static final int Ieee802_VALUE = 6;
    /**
     * <code>ArcNet = 7;</code>
     */
    public static final int ArcNet_VALUE = 7;
    /**
     * <code>Slip = 8;</code>
     */
    public static final int Slip_VALUE = 8;
    /**
     * <code>Ppp = 9;</code>
     */
    public static final int Ppp_VALUE = 9;
    /**
     * <code>Fddi = 10;</code>
     */
    public static final int Fddi_VALUE = 10;
    /**
     * <code>AtmRfc1483 = 11;</code>
     */
    public static final int AtmRfc1483_VALUE = 11;
    /**
     * <code>Raw = 12;</code>
     */
    public static final int Raw_VALUE = 12;
    /**
     * <code>SlipBSD = 15;</code>
     */
    public static final int SlipBSD_VALUE = 15;
    /**
     * <code>PppBSD = 16;</code>
     */
    public static final int PppBSD_VALUE = 16;
    /**
     * <code>AtmClip = 19;</code>
     */
    public static final int AtmClip_VALUE = 19;
    /**
     * <code>PppSerial = 50;</code>
     */
    public static final int PppSerial_VALUE = 50;
    /**
     * <code>CiscoHDLC = 104;</code>
     */
    public static final int CiscoHDLC_VALUE = 104;
    /**
     * <code>Ieee80211 = 105;</code>
     */
    public static final int Ieee80211_VALUE = 105;
    /**
     * <code>Loop = 108;</code>
     */
    public static final int Loop_VALUE = 108;
    /**
     * <code>LinuxSLL = 113;</code>
     */
    public static final int LinuxSLL_VALUE = 113;
    /**
     * <code>Ieee80211_Radio = 127;</code>
     */
    public static final int Ieee80211_Radio_VALUE = 127;
    /**
     * <code>PerPacketInformation = 192;</code>
     */
    public static final int PerPacketInformation_VALUE = 192;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static DataLinkType valueOf(int value) {
      return forNumber(value);
    }

    public static DataLinkType forNumber(int value) {
      switch (value) {
        case 0: return Null;
        case 1: return Ethernet;
        case 2: return ExperimentalEthernet3MB;
        case 3: return AmateurRadioAX25;
        case 4: return ProteonProNetTokenRing;
        case 5: return Chaos;
        case 6: return Ieee802;
        case 7: return ArcNet;
        case 8: return Slip;
        case 9: return Ppp;
        case 10: return Fddi;
        case 11: return AtmRfc1483;
        case 12: return Raw;
        case 15: return SlipBSD;
        case 16: return PppBSD;
        case 19: return AtmClip;
        case 50: return PppSerial;
        case 104: return CiscoHDLC;
        case 105: return Ieee80211;
        case 108: return Loop;
        case 113: return LinuxSLL;
        case 127: return Ieee80211_Radio;
        case 192: return PerPacketInformation;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<DataLinkType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        DataLinkType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<DataLinkType>() {
            public DataLinkType findValueByNumber(int number) {
              return DataLinkType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.ndx.model.Constants.getDescriptor().getEnumTypes().get(0);
    }

    private static final DataLinkType[] VALUES = values();

    public static DataLinkType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private DataLinkType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ndx.model.DataLinkType)
  }

  /**
   * Protobuf enum {@code ndx.model.EthernetPacketType}
   */
  public enum EthernetPacketType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / No Ethernet type
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>None = 0;</code>
     */
    None(0),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Internet Protocol; Version 4 (IPv4)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>IpV4 = 2048;</code>
     */
    IpV4(2048),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Address Resolution Protocol (ARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Arp = 2054;</code>
     */
    Arp(2054),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Reverse Address Resolution Protocol (RARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ReverseArp = 32821;</code>
     */
    ReverseArp(32821),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Wake-On-Lan (WOL)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>WakeOnLan = 2114;</code>
     */
    WakeOnLan(2114),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AppleTalk (Ethertalk)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AppleTalk = 32923;</code>
     */
    AppleTalk(32923),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AppleTalk Address Resolution Protocol (AARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AppleTalkArp = 33011;</code>
     */
    AppleTalkArp(33011),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / VLAN-tagged frame (IEEE 802.1Q)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>VLanTaggedFrame = 33024;</code>
     */
    VLanTaggedFrame(33024),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Novell IPX (alt)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>NovellInternetworkPacketExchange = 33079;</code>
     */
    NovellInternetworkPacketExchange(33079),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Novell
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Novell = 33080;</code>
     */
    Novell(33080),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Internet Protocol; Version 6 (IPv6)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>IpV6 = 34525;</code>
     */
    IpV6(34525),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MAC Control
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MacControl = 34824;</code>
     */
    MacControl(34824),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / CobraNet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>CobraNet = 34841;</code>
     */
    CobraNet(34841),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MPLS unicast
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MultiprotocolLabelSwitchingUnicast = 34887;</code>
     */
    MultiprotocolLabelSwitchingUnicast(34887),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MPLS multicast
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MultiprotocolLabelSwitchingMulticast = 34888;</code>
     */
    MultiprotocolLabelSwitchingMulticast(34888),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / PPPoE Discovery Stage
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PointToPointProtocolOverEthernetDiscoveryStage = 34915;</code>
     */
    PointToPointProtocolOverEthernetDiscoveryStage(34915),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / PPPoE Session Stage
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PointToPointProtocolOverEthernetSessionStage = 34916;</code>
     */
    PointToPointProtocolOverEthernetSessionStage(34916),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / EAP over LAN (IEEE 802.1X)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ExtensibleAuthenticationProtocolOverLan = 34958;</code>
     */
    ExtensibleAuthenticationProtocolOverLan(34958),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / HyperSCSI (SCSI over Ethernet)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>HyperScsi = 34970;</code>
     */
    HyperScsi(34970),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / ATA over Ethernet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AtaOverEthernet = 34978;</code>
     */
    AtaOverEthernet(34978),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / EtherCAT Protocol
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>EtherCatProtocol = 34980;</code>
     */
    EtherCatProtocol(34980),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Provider Bridging (IEEE 802.1ad)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ProviderBridging = 34984;</code>
     */
    ProviderBridging(34984),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AVB Transport Protocol (AVBTP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AvbTransportProtocol = 34997;</code>
     */
    AvbTransportProtocol(34997),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Link Layer Discovery Protocol (LLDP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>LLDP = 35020;</code>
     */
    LLDP(35020),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / SERCOS III
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>SerialRealTimeCommunicationSystemIii = 35021;</code>
     */
    SerialRealTimeCommunicationSystemIii(35021),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Circuit Emulation Services over Ethernet (MEF-8)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>CircuitEmulationServicesOverEthernet = 35032;</code>
     */
    CircuitEmulationServicesOverEthernet(35032),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / HomePlug
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>HomePlug = 35041;</code>
     */
    HomePlug(35041),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MAC security (IEEE 802.1AE)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MacSecurity = 35045;</code>
     */
    MacSecurity(35045),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Precision Time Protocol (IEEE 1588)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PrecisionTimeProtocol = 35063;</code>
     */
    PrecisionTimeProtocol(35063),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / IEEE 802.1ag Connectivity Fault Management (CFM) Protocol / ITU-T Recommendation Y.1731 (OAM)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ConnectivityFaultManagementOrOperationsAdministrationManagement = 35074;</code>
     */
    ConnectivityFaultManagementOrOperationsAdministrationManagement(35074),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Fibre Channel over Ethernet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>FibreChannelOverEthernet = 35078;</code>
     */
    FibreChannelOverEthernet(35078),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / FCoE Initialization Protocol
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>FibreChannelOverEthernetInitializationProtocol = 35092;</code>
     */
    FibreChannelOverEthernetInitializationProtocol(35092),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Q-in-Q
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>QInQ = 37120;</code>
     */
    QInQ(37120),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Veritas Low Latency Transport (LLT)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>VeritasLowLatencyTransport = 51966;</code>
     */
    VeritasLowLatencyTransport(51966),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Ethernet loopback packet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Loopback = 96;</code>
     */
    Loopback(96),
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Ethernet echo packet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Echo = 512;</code>
     */
    Echo(512),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / No Ethernet type
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>None = 0;</code>
     */
    public static final int None_VALUE = 0;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Internet Protocol; Version 4 (IPv4)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>IpV4 = 2048;</code>
     */
    public static final int IpV4_VALUE = 2048;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Address Resolution Protocol (ARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Arp = 2054;</code>
     */
    public static final int Arp_VALUE = 2054;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Reverse Address Resolution Protocol (RARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ReverseArp = 32821;</code>
     */
    public static final int ReverseArp_VALUE = 32821;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Wake-On-Lan (WOL)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>WakeOnLan = 2114;</code>
     */
    public static final int WakeOnLan_VALUE = 2114;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AppleTalk (Ethertalk)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AppleTalk = 32923;</code>
     */
    public static final int AppleTalk_VALUE = 32923;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AppleTalk Address Resolution Protocol (AARP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AppleTalkArp = 33011;</code>
     */
    public static final int AppleTalkArp_VALUE = 33011;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / VLAN-tagged frame (IEEE 802.1Q)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>VLanTaggedFrame = 33024;</code>
     */
    public static final int VLanTaggedFrame_VALUE = 33024;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Novell IPX (alt)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>NovellInternetworkPacketExchange = 33079;</code>
     */
    public static final int NovellInternetworkPacketExchange_VALUE = 33079;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Novell
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Novell = 33080;</code>
     */
    public static final int Novell_VALUE = 33080;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Internet Protocol; Version 6 (IPv6)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>IpV6 = 34525;</code>
     */
    public static final int IpV6_VALUE = 34525;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MAC Control
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MacControl = 34824;</code>
     */
    public static final int MacControl_VALUE = 34824;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / CobraNet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>CobraNet = 34841;</code>
     */
    public static final int CobraNet_VALUE = 34841;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MPLS unicast
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MultiprotocolLabelSwitchingUnicast = 34887;</code>
     */
    public static final int MultiprotocolLabelSwitchingUnicast_VALUE = 34887;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MPLS multicast
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MultiprotocolLabelSwitchingMulticast = 34888;</code>
     */
    public static final int MultiprotocolLabelSwitchingMulticast_VALUE = 34888;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / PPPoE Discovery Stage
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PointToPointProtocolOverEthernetDiscoveryStage = 34915;</code>
     */
    public static final int PointToPointProtocolOverEthernetDiscoveryStage_VALUE = 34915;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / PPPoE Session Stage
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PointToPointProtocolOverEthernetSessionStage = 34916;</code>
     */
    public static final int PointToPointProtocolOverEthernetSessionStage_VALUE = 34916;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / EAP over LAN (IEEE 802.1X)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ExtensibleAuthenticationProtocolOverLan = 34958;</code>
     */
    public static final int ExtensibleAuthenticationProtocolOverLan_VALUE = 34958;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / HyperSCSI (SCSI over Ethernet)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>HyperScsi = 34970;</code>
     */
    public static final int HyperScsi_VALUE = 34970;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / ATA over Ethernet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AtaOverEthernet = 34978;</code>
     */
    public static final int AtaOverEthernet_VALUE = 34978;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / EtherCAT Protocol
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>EtherCatProtocol = 34980;</code>
     */
    public static final int EtherCatProtocol_VALUE = 34980;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Provider Bridging (IEEE 802.1ad)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ProviderBridging = 34984;</code>
     */
    public static final int ProviderBridging_VALUE = 34984;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / AVB Transport Protocol (AVBTP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>AvbTransportProtocol = 34997;</code>
     */
    public static final int AvbTransportProtocol_VALUE = 34997;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Link Layer Discovery Protocol (LLDP)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>LLDP = 35020;</code>
     */
    public static final int LLDP_VALUE = 35020;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / SERCOS III
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>SerialRealTimeCommunicationSystemIii = 35021;</code>
     */
    public static final int SerialRealTimeCommunicationSystemIii_VALUE = 35021;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Circuit Emulation Services over Ethernet (MEF-8)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>CircuitEmulationServicesOverEthernet = 35032;</code>
     */
    public static final int CircuitEmulationServicesOverEthernet_VALUE = 35032;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / HomePlug
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>HomePlug = 35041;</code>
     */
    public static final int HomePlug_VALUE = 35041;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / MAC security (IEEE 802.1AE)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>MacSecurity = 35045;</code>
     */
    public static final int MacSecurity_VALUE = 35045;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Precision Time Protocol (IEEE 1588)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>PrecisionTimeProtocol = 35063;</code>
     */
    public static final int PrecisionTimeProtocol_VALUE = 35063;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / IEEE 802.1ag Connectivity Fault Management (CFM) Protocol / ITU-T Recommendation Y.1731 (OAM)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>ConnectivityFaultManagementOrOperationsAdministrationManagement = 35074;</code>
     */
    public static final int ConnectivityFaultManagementOrOperationsAdministrationManagement_VALUE = 35074;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Fibre Channel over Ethernet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>FibreChannelOverEthernet = 35078;</code>
     */
    public static final int FibreChannelOverEthernet_VALUE = 35078;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / FCoE Initialization Protocol
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>FibreChannelOverEthernetInitializationProtocol = 35092;</code>
     */
    public static final int FibreChannelOverEthernetInitializationProtocol_VALUE = 35092;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Q-in-Q
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>QInQ = 37120;</code>
     */
    public static final int QInQ_VALUE = 37120;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Veritas Low Latency Transport (LLT)
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>VeritasLowLatencyTransport = 51966;</code>
     */
    public static final int VeritasLowLatencyTransport_VALUE = 51966;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Ethernet loopback packet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Loopback = 96;</code>
     */
    public static final int Loopback_VALUE = 96;
    /**
     * <pre>
     *&#47; &lt;summary&gt;
     * / Ethernet echo packet
     * / &lt;/summary&gt;
     * </pre>
     *
     * <code>Echo = 512;</code>
     */
    public static final int Echo_VALUE = 512;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static EthernetPacketType valueOf(int value) {
      return forNumber(value);
    }

    public static EthernetPacketType forNumber(int value) {
      switch (value) {
        case 0: return None;
        case 2048: return IpV4;
        case 2054: return Arp;
        case 32821: return ReverseArp;
        case 2114: return WakeOnLan;
        case 32923: return AppleTalk;
        case 33011: return AppleTalkArp;
        case 33024: return VLanTaggedFrame;
        case 33079: return NovellInternetworkPacketExchange;
        case 33080: return Novell;
        case 34525: return IpV6;
        case 34824: return MacControl;
        case 34841: return CobraNet;
        case 34887: return MultiprotocolLabelSwitchingUnicast;
        case 34888: return MultiprotocolLabelSwitchingMulticast;
        case 34915: return PointToPointProtocolOverEthernetDiscoveryStage;
        case 34916: return PointToPointProtocolOverEthernetSessionStage;
        case 34958: return ExtensibleAuthenticationProtocolOverLan;
        case 34970: return HyperScsi;
        case 34978: return AtaOverEthernet;
        case 34980: return EtherCatProtocol;
        case 34984: return ProviderBridging;
        case 34997: return AvbTransportProtocol;
        case 35020: return LLDP;
        case 35021: return SerialRealTimeCommunicationSystemIii;
        case 35032: return CircuitEmulationServicesOverEthernet;
        case 35041: return HomePlug;
        case 35045: return MacSecurity;
        case 35063: return PrecisionTimeProtocol;
        case 35074: return ConnectivityFaultManagementOrOperationsAdministrationManagement;
        case 35078: return FibreChannelOverEthernet;
        case 35092: return FibreChannelOverEthernetInitializationProtocol;
        case 37120: return QInQ;
        case 51966: return VeritasLowLatencyTransport;
        case 96: return Loopback;
        case 512: return Echo;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EthernetPacketType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        EthernetPacketType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EthernetPacketType>() {
            public EthernetPacketType findValueByNumber(int number) {
              return EthernetPacketType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.ndx.model.Constants.getDescriptor().getEnumTypes().get(1);
    }

    private static final EthernetPacketType[] VALUES = values();

    public static EthernetPacketType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private EthernetPacketType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ndx.model.EthernetPacketType)
  }

  /**
   * <pre>
   *&#47; &lt;summary&gt; Dummy protocol for TCP. &lt;/summary&gt;
   * </pre>
   *
   * Protobuf enum {@code ndx.model.IpProtocolType}
   */
  public enum IpProtocolType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 Hop-by-Hop options. &lt;/summary&gt;
     * </pre>
     *
     * <code>HOPOPTS = 0;</code>
     */
    HOPOPTS(0),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Internet Control Message Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>ICMP = 1;</code>
     */
    ICMP(1),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Internet Group Management Protocol.&lt;/summary&gt;
     * </pre>
     *
     * <code>IGMP = 2;</code>
     */
    IGMP(2),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPIP tunnels (older KA9Q tunnels use 94). &lt;/summary&gt;
     * </pre>
     *
     * <code>IPIP = 4;</code>
     */
    IPIP(4),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Transmission Control Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>TCP = 6;</code>
     */
    TCP(6),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Exterior Gateway Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>EGP = 8;</code>
     */
    EGP(8),
    /**
     * <pre>
     *&#47; &lt;summary&gt; PUP protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>PUP = 12;</code>
     */
    PUP(12),
    /**
     * <pre>
     *&#47; &lt;summary&gt; User Datagram Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>UDP = 17;</code>
     */
    UDP(17),
    /**
     * <pre>
     *&#47; &lt;summary&gt; XNS IDP protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>IDP = 22;</code>
     */
    IDP(22),
    /**
     * <pre>
     *&#47; &lt;summary&gt; SO Transport Protocol Class 4. &lt;/summary&gt;
     * </pre>
     *
     * <code>TP = 29;</code>
     */
    TP(29),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 header. &lt;/summary&gt;
     * </pre>
     *
     * <code>IPv6 = 41;</code>
     */
    IPv6(41),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 routing header. &lt;/summary&gt;
     * </pre>
     *
     * <code>ROUTING = 43;</code>
     */
    ROUTING(43),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 fragmentation header. &lt;/summary&gt;
     * </pre>
     *
     * <code>FRAGMENT = 44;</code>
     */
    FRAGMENT(44),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Reservation Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>RSVP = 46;</code>
     */
    RSVP(46),
    /**
     * <pre>
     *&#47; &lt;summary&gt; General Routing Encapsulation. &lt;/summary&gt;
     * </pre>
     *
     * <code>GRE = 47;</code>
     */
    GRE(47),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Encapsulating security payload. &lt;/summary&gt;
     * </pre>
     *
     * <code>ESP = 50;</code>
     */
    ESP(50),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Authentication header. &lt;/summary&gt;
     * </pre>
     *
     * <code>AH = 51;</code>
     */
    AH(51),
    /**
     * <pre>
     *&#47; &lt;summary&gt; ICMPv6. &lt;/summary&gt;
     * </pre>
     *
     * <code>ICMPV6 = 58;</code>
     */
    ICMPV6(58),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 no next header. &lt;/summary&gt;
     * </pre>
     *
     * <code>NONE = 59;</code>
     */
    NONE(59),
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 destination options. &lt;/summary&gt;
     * </pre>
     *
     * <code>DSTOPTS = 60;</code>
     */
    DSTOPTS(60),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Multicast Transport Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>MTP = 92;</code>
     */
    MTP(92),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Encapsulation Header. &lt;/summary&gt;
     * </pre>
     *
     * <code>ENCAP = 98;</code>
     */
    ENCAP(98),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Protocol Independent Multicast. &lt;/summary&gt;
     * </pre>
     *
     * <code>PIM = 103;</code>
     */
    PIM(103),
    /**
     * <pre>
     *&#47; &lt;summary&gt; Compression Header Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>COMP = 108;</code>
     */
    COMP(108),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 Hop-by-Hop options. &lt;/summary&gt;
     * </pre>
     *
     * <code>HOPOPTS = 0;</code>
     */
    public static final int HOPOPTS_VALUE = 0;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Internet Control Message Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>ICMP = 1;</code>
     */
    public static final int ICMP_VALUE = 1;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Internet Group Management Protocol.&lt;/summary&gt;
     * </pre>
     *
     * <code>IGMP = 2;</code>
     */
    public static final int IGMP_VALUE = 2;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPIP tunnels (older KA9Q tunnels use 94). &lt;/summary&gt;
     * </pre>
     *
     * <code>IPIP = 4;</code>
     */
    public static final int IPIP_VALUE = 4;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Transmission Control Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>TCP = 6;</code>
     */
    public static final int TCP_VALUE = 6;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Exterior Gateway Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>EGP = 8;</code>
     */
    public static final int EGP_VALUE = 8;
    /**
     * <pre>
     *&#47; &lt;summary&gt; PUP protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>PUP = 12;</code>
     */
    public static final int PUP_VALUE = 12;
    /**
     * <pre>
     *&#47; &lt;summary&gt; User Datagram Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>UDP = 17;</code>
     */
    public static final int UDP_VALUE = 17;
    /**
     * <pre>
     *&#47; &lt;summary&gt; XNS IDP protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>IDP = 22;</code>
     */
    public static final int IDP_VALUE = 22;
    /**
     * <pre>
     *&#47; &lt;summary&gt; SO Transport Protocol Class 4. &lt;/summary&gt;
     * </pre>
     *
     * <code>TP = 29;</code>
     */
    public static final int TP_VALUE = 29;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 header. &lt;/summary&gt;
     * </pre>
     *
     * <code>IPv6 = 41;</code>
     */
    public static final int IPv6_VALUE = 41;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 routing header. &lt;/summary&gt;
     * </pre>
     *
     * <code>ROUTING = 43;</code>
     */
    public static final int ROUTING_VALUE = 43;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 fragmentation header. &lt;/summary&gt;
     * </pre>
     *
     * <code>FRAGMENT = 44;</code>
     */
    public static final int FRAGMENT_VALUE = 44;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Reservation Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>RSVP = 46;</code>
     */
    public static final int RSVP_VALUE = 46;
    /**
     * <pre>
     *&#47; &lt;summary&gt; General Routing Encapsulation. &lt;/summary&gt;
     * </pre>
     *
     * <code>GRE = 47;</code>
     */
    public static final int GRE_VALUE = 47;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Encapsulating security payload. &lt;/summary&gt;
     * </pre>
     *
     * <code>ESP = 50;</code>
     */
    public static final int ESP_VALUE = 50;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Authentication header. &lt;/summary&gt;
     * </pre>
     *
     * <code>AH = 51;</code>
     */
    public static final int AH_VALUE = 51;
    /**
     * <pre>
     *&#47; &lt;summary&gt; ICMPv6. &lt;/summary&gt;
     * </pre>
     *
     * <code>ICMPV6 = 58;</code>
     */
    public static final int ICMPV6_VALUE = 58;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 no next header. &lt;/summary&gt;
     * </pre>
     *
     * <code>NONE = 59;</code>
     */
    public static final int NONE_VALUE = 59;
    /**
     * <pre>
     *&#47; &lt;summary&gt; IPv6 destination options. &lt;/summary&gt;
     * </pre>
     *
     * <code>DSTOPTS = 60;</code>
     */
    public static final int DSTOPTS_VALUE = 60;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Multicast Transport Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>MTP = 92;</code>
     */
    public static final int MTP_VALUE = 92;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Encapsulation Header. &lt;/summary&gt;
     * </pre>
     *
     * <code>ENCAP = 98;</code>
     */
    public static final int ENCAP_VALUE = 98;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Protocol Independent Multicast. &lt;/summary&gt;
     * </pre>
     *
     * <code>PIM = 103;</code>
     */
    public static final int PIM_VALUE = 103;
    /**
     * <pre>
     *&#47; &lt;summary&gt; Compression Header Protocol. &lt;/summary&gt;
     * </pre>
     *
     * <code>COMP = 108;</code>
     */
    public static final int COMP_VALUE = 108;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static IpProtocolType valueOf(int value) {
      return forNumber(value);
    }

    public static IpProtocolType forNumber(int value) {
      switch (value) {
        case 0: return HOPOPTS;
        case 1: return ICMP;
        case 2: return IGMP;
        case 4: return IPIP;
        case 6: return TCP;
        case 8: return EGP;
        case 12: return PUP;
        case 17: return UDP;
        case 22: return IDP;
        case 29: return TP;
        case 41: return IPv6;
        case 43: return ROUTING;
        case 44: return FRAGMENT;
        case 46: return RSVP;
        case 47: return GRE;
        case 50: return ESP;
        case 51: return AH;
        case 58: return ICMPV6;
        case 59: return NONE;
        case 60: return DSTOPTS;
        case 92: return MTP;
        case 98: return ENCAP;
        case 103: return PIM;
        case 108: return COMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<IpProtocolType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        IpProtocolType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<IpProtocolType>() {
            public IpProtocolType findValueByNumber(int number) {
              return IpProtocolType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return org.ndx.model.Constants.getDescriptor().getEnumTypes().get(2);
    }

    private static final IpProtocolType[] VALUES = values();

    public static IpProtocolType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private IpProtocolType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:ndx.model.IpProtocolType)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\017Constants.proto\022\tndx.model*\352\002\n\014DataLin" +
      "kType\022\010\n\004Null\020\000\022\014\n\010Ethernet\020\001\022\033\n\027Experim" +
      "entalEthernet3MB\020\002\022\024\n\020AmateurRadioAX25\020\003" +
      "\022\032\n\026ProteonProNetTokenRing\020\004\022\t\n\005Chaos\020\005\022" +
      "\013\n\007Ieee802\020\006\022\n\n\006ArcNet\020\007\022\010\n\004Slip\020\010\022\007\n\003Pp" +
      "p\020\t\022\010\n\004Fddi\020\n\022\016\n\nAtmRfc1483\020\013\022\007\n\003Raw\020\014\022\013" +
      "\n\007SlipBSD\020\017\022\n\n\006PppBSD\020\020\022\013\n\007AtmClip\020\023\022\r\n\t" +
      "PppSerial\0202\022\r\n\tCiscoHDLC\020h\022\r\n\tIeee80211\020" +
      "i\022\010\n\004Loop\020l\022\014\n\010LinuxSLL\020q\022\023\n\017Ieee80211_R" +
      "adio\020\177\022\031\n\024PerPacketInformation\020\300\001*\340\007\n\022Et",
      "hernetPacketType\022\010\n\004None\020\000\022\t\n\004IpV4\020\200\020\022\010\n" +
      "\003Arp\020\206\020\022\020\n\nReverseArp\020\265\200\002\022\016\n\tWakeOnLan\020\302" +
      "\020\022\017\n\tAppleTalk\020\233\201\002\022\022\n\014AppleTalkArp\020\363\201\002\022\025" +
      "\n\017VLanTaggedFrame\020\200\202\002\022&\n NovellInternetw" +
      "orkPacketExchange\020\267\202\002\022\014\n\006Novell\020\270\202\002\022\n\n\004I" +
      "pV6\020\335\215\002\022\020\n\nMacControl\020\210\220\002\022\016\n\010CobraNet\020\231\220" +
      "\002\022(\n\"MultiprotocolLabelSwitchingUnicast\020" +
      "\307\220\002\022*\n$MultiprotocolLabelSwitchingMultic" +
      "ast\020\310\220\002\0224\n.PointToPointProtocolOverEther" +
      "netDiscoveryStage\020\343\220\002\0222\n,PointToPointPro",
      "tocolOverEthernetSessionStage\020\344\220\002\022-\n\'Ext" +
      "ensibleAuthenticationProtocolOverLan\020\216\221\002" +
      "\022\017\n\tHyperScsi\020\232\221\002\022\025\n\017AtaOverEthernet\020\242\221\002" +
      "\022\026\n\020EtherCatProtocol\020\244\221\002\022\026\n\020ProviderBrid" +
      "ging\020\250\221\002\022\032\n\024AvbTransportProtocol\020\265\221\002\022\n\n\004" +
      "LLDP\020\314\221\002\022*\n$SerialRealTimeCommunicationS" +
      "ystemIii\020\315\221\002\022*\n$CircuitEmulationServices" +
      "OverEthernet\020\330\221\002\022\016\n\010HomePlug\020\341\221\002\022\021\n\013MacS" +
      "ecurity\020\345\221\002\022\033\n\025PrecisionTimeProtocol\020\367\221\002" +
      "\022E\n?ConnectivityFaultManagementOrOperati",
      "onsAdministrationManagement\020\202\222\002\022\036\n\030Fibre" +
      "ChannelOverEthernet\020\206\222\002\0224\n.FibreChannelO" +
      "verEthernetInitializationProtocol\020\224\222\002\022\n\n" +
      "\004QInQ\020\200\242\002\022 \n\032VeritasLowLatencyTransport\020" +
      "\376\225\003\022\014\n\010Loopback\020`\022\t\n\004Echo\020\200\004*\203\002\n\016IpProto" +
      "colType\022\013\n\007HOPOPTS\020\000\022\010\n\004ICMP\020\001\022\010\n\004IGMP\020\002" +
      "\022\010\n\004IPIP\020\004\022\007\n\003TCP\020\006\022\007\n\003EGP\020\010\022\007\n\003PUP\020\014\022\007\n" +
      "\003UDP\020\021\022\007\n\003IDP\020\026\022\006\n\002TP\020\035\022\010\n\004IPv6\020)\022\013\n\007ROU" +
      "TING\020+\022\014\n\010FRAGMENT\020,\022\010\n\004RSVP\020.\022\007\n\003GRE\020/\022" +
      "\007\n\003ESP\0202\022\006\n\002AH\0203\022\n\n\006ICMPV6\020:\022\010\n\004NONE\020;\022\013",
      "\n\007DSTOPTS\020<\022\007\n\003MTP\020\\\022\t\n\005ENCAP\020b\022\007\n\003PIM\020g" +
      "\022\010\n\004COMP\020lB\017\n\rorg.ndx.modelb\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
